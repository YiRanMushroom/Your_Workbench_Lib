// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

export namespace std {

  using ::double_t _LIBCPP_USING_IF_EXISTS;
  using ::float_t _LIBCPP_USING_IF_EXISTS;

  using ::acos _LIBCPP_USING_IF_EXISTS;
  using ::acosf _LIBCPP_USING_IF_EXISTS;
  using ::acosl _LIBCPP_USING_IF_EXISTS;

  using ::asin _LIBCPP_USING_IF_EXISTS;
  using ::asinf _LIBCPP_USING_IF_EXISTS;
  using ::asinl _LIBCPP_USING_IF_EXISTS;

  using ::atan _LIBCPP_USING_IF_EXISTS;
  using ::atanf _LIBCPP_USING_IF_EXISTS;
  using ::atanl _LIBCPP_USING_IF_EXISTS;

  using ::atan2 _LIBCPP_USING_IF_EXISTS;
  using ::atan2f _LIBCPP_USING_IF_EXISTS;
  using ::atan2l _LIBCPP_USING_IF_EXISTS;

  using ::cos _LIBCPP_USING_IF_EXISTS;
  using ::cosf _LIBCPP_USING_IF_EXISTS;
  using ::cosl _LIBCPP_USING_IF_EXISTS;

  using ::sin _LIBCPP_USING_IF_EXISTS;
  using ::sinf _LIBCPP_USING_IF_EXISTS;
  using ::sinl _LIBCPP_USING_IF_EXISTS;

  using ::tan _LIBCPP_USING_IF_EXISTS;
  using ::tanf _LIBCPP_USING_IF_EXISTS;
  using ::tanl _LIBCPP_USING_IF_EXISTS;

  using ::acosh _LIBCPP_USING_IF_EXISTS;
  using ::acoshf _LIBCPP_USING_IF_EXISTS;
  using ::acoshl _LIBCPP_USING_IF_EXISTS;

  using ::asinh _LIBCPP_USING_IF_EXISTS;
  using ::asinhf _LIBCPP_USING_IF_EXISTS;
  using ::asinhl _LIBCPP_USING_IF_EXISTS;

  using ::atanh _LIBCPP_USING_IF_EXISTS;
  using ::atanhf _LIBCPP_USING_IF_EXISTS;
  using ::atanhl _LIBCPP_USING_IF_EXISTS;

  using ::cosh _LIBCPP_USING_IF_EXISTS;
  using ::coshf _LIBCPP_USING_IF_EXISTS;
  using ::coshl _LIBCPP_USING_IF_EXISTS;

  using ::sinh _LIBCPP_USING_IF_EXISTS;
  using ::sinhf _LIBCPP_USING_IF_EXISTS;
  using ::sinhl _LIBCPP_USING_IF_EXISTS;

  using ::tanh _LIBCPP_USING_IF_EXISTS;
  using ::tanhf _LIBCPP_USING_IF_EXISTS;
  using ::tanhl _LIBCPP_USING_IF_EXISTS;

  using ::exp _LIBCPP_USING_IF_EXISTS;
  using ::expf _LIBCPP_USING_IF_EXISTS;
  using ::expl _LIBCPP_USING_IF_EXISTS;

  using ::exp2 _LIBCPP_USING_IF_EXISTS;
  using ::exp2f _LIBCPP_USING_IF_EXISTS;
  using ::exp2l _LIBCPP_USING_IF_EXISTS;

  using ::expm1 _LIBCPP_USING_IF_EXISTS;
  using ::expm1f _LIBCPP_USING_IF_EXISTS;
  using ::expm1l _LIBCPP_USING_IF_EXISTS;

  using ::frexp _LIBCPP_USING_IF_EXISTS;
  using ::frexpf _LIBCPP_USING_IF_EXISTS;
  using ::frexpl _LIBCPP_USING_IF_EXISTS;

  using ::ilogb _LIBCPP_USING_IF_EXISTS;
  using ::ilogbf _LIBCPP_USING_IF_EXISTS;
  using ::ilogbl _LIBCPP_USING_IF_EXISTS;

  using ::ldexp _LIBCPP_USING_IF_EXISTS;
  using ::ldexpf _LIBCPP_USING_IF_EXISTS;
  using ::ldexpl _LIBCPP_USING_IF_EXISTS;

  using ::log _LIBCPP_USING_IF_EXISTS;
  using ::logf _LIBCPP_USING_IF_EXISTS;
  using ::logl _LIBCPP_USING_IF_EXISTS;

  using ::log10 _LIBCPP_USING_IF_EXISTS;
  using ::log10f _LIBCPP_USING_IF_EXISTS;
  using ::log10l _LIBCPP_USING_IF_EXISTS;

  using ::log1p _LIBCPP_USING_IF_EXISTS;
  using ::log1pf _LIBCPP_USING_IF_EXISTS;
  using ::log1pl _LIBCPP_USING_IF_EXISTS;

  using ::log2 _LIBCPP_USING_IF_EXISTS;
  using ::log2f _LIBCPP_USING_IF_EXISTS;
  using ::log2l _LIBCPP_USING_IF_EXISTS;

  using ::logb _LIBCPP_USING_IF_EXISTS;
  using ::logbf _LIBCPP_USING_IF_EXISTS;
  using ::logbl _LIBCPP_USING_IF_EXISTS;

  using ::modf _LIBCPP_USING_IF_EXISTS;
  using ::modff _LIBCPP_USING_IF_EXISTS;
  using ::modfl _LIBCPP_USING_IF_EXISTS;

  using ::scalbn _LIBCPP_USING_IF_EXISTS;
  using ::scalbnf _LIBCPP_USING_IF_EXISTS;
  using ::scalbnl _LIBCPP_USING_IF_EXISTS;

  using ::scalbln _LIBCPP_USING_IF_EXISTS;
  using ::scalblnf _LIBCPP_USING_IF_EXISTS;
  using ::scalblnl _LIBCPP_USING_IF_EXISTS;

  using ::cbrt _LIBCPP_USING_IF_EXISTS;
  using ::cbrtf _LIBCPP_USING_IF_EXISTS;
  using ::cbrtl _LIBCPP_USING_IF_EXISTS;

  // [c.h.abs], absolute values
  using ::abs _LIBCPP_USING_IF_EXISTS;

  using ::fabs _LIBCPP_USING_IF_EXISTS;
  using ::fabsf _LIBCPP_USING_IF_EXISTS;
  using ::fabsl _LIBCPP_USING_IF_EXISTS;

  using ::hypot _LIBCPP_USING_IF_EXISTS;
  using ::hypotf _LIBCPP_USING_IF_EXISTS;
  using ::hypotl _LIBCPP_USING_IF_EXISTS;

  // [c.h.hypot3], three-dimensional hypotenuse

  using ::pow _LIBCPP_USING_IF_EXISTS;
  using ::powf _LIBCPP_USING_IF_EXISTS;
  using ::powl _LIBCPP_USING_IF_EXISTS;

  using ::sqrt _LIBCPP_USING_IF_EXISTS;
  using ::sqrtf _LIBCPP_USING_IF_EXISTS;
  using ::sqrtl _LIBCPP_USING_IF_EXISTS;

  using ::erf _LIBCPP_USING_IF_EXISTS;
  using ::erff _LIBCPP_USING_IF_EXISTS;
  using ::erfl _LIBCPP_USING_IF_EXISTS;

  using ::erfc _LIBCPP_USING_IF_EXISTS;
  using ::erfcf _LIBCPP_USING_IF_EXISTS;
  using ::erfcl _LIBCPP_USING_IF_EXISTS;

  using ::lgamma _LIBCPP_USING_IF_EXISTS;
  using ::lgammaf _LIBCPP_USING_IF_EXISTS;
  using ::lgammal _LIBCPP_USING_IF_EXISTS;

  using ::tgamma _LIBCPP_USING_IF_EXISTS;
  using ::tgammaf _LIBCPP_USING_IF_EXISTS;
  using ::tgammal _LIBCPP_USING_IF_EXISTS;

  using ::ceil _LIBCPP_USING_IF_EXISTS;
  using ::ceilf _LIBCPP_USING_IF_EXISTS;
  using ::ceill _LIBCPP_USING_IF_EXISTS;

  using ::floor _LIBCPP_USING_IF_EXISTS;
  using ::floorf _LIBCPP_USING_IF_EXISTS;
  using ::floorl _LIBCPP_USING_IF_EXISTS;

  using ::nearbyint _LIBCPP_USING_IF_EXISTS;
  using ::nearbyintf _LIBCPP_USING_IF_EXISTS;
  using ::nearbyintl _LIBCPP_USING_IF_EXISTS;

  using ::rint _LIBCPP_USING_IF_EXISTS;
  using ::rintf _LIBCPP_USING_IF_EXISTS;
  using ::rintl _LIBCPP_USING_IF_EXISTS;

  using ::lrint _LIBCPP_USING_IF_EXISTS;
  using ::lrintf _LIBCPP_USING_IF_EXISTS;
  using ::lrintl _LIBCPP_USING_IF_EXISTS;

  using ::llrint _LIBCPP_USING_IF_EXISTS;
  using ::llrintf _LIBCPP_USING_IF_EXISTS;
  using ::llrintl _LIBCPP_USING_IF_EXISTS;

  using ::round _LIBCPP_USING_IF_EXISTS;
  using ::roundf _LIBCPP_USING_IF_EXISTS;
  using ::roundl _LIBCPP_USING_IF_EXISTS;

  using ::lround _LIBCPP_USING_IF_EXISTS;
  using ::lroundf _LIBCPP_USING_IF_EXISTS;
  using ::lroundl _LIBCPP_USING_IF_EXISTS;

  using ::llround _LIBCPP_USING_IF_EXISTS;
  using ::llroundf _LIBCPP_USING_IF_EXISTS;
  using ::llroundl _LIBCPP_USING_IF_EXISTS;

  using ::trunc _LIBCPP_USING_IF_EXISTS;
  using ::truncf _LIBCPP_USING_IF_EXISTS;
  using ::truncl _LIBCPP_USING_IF_EXISTS;

  using ::fmod _LIBCPP_USING_IF_EXISTS;
  using ::fmodf _LIBCPP_USING_IF_EXISTS;
  using ::fmodl _LIBCPP_USING_IF_EXISTS;

  using ::remainder _LIBCPP_USING_IF_EXISTS;
  using ::remainderf _LIBCPP_USING_IF_EXISTS;
  using ::remainderl _LIBCPP_USING_IF_EXISTS;

  using ::remquo _LIBCPP_USING_IF_EXISTS;
  using ::remquof _LIBCPP_USING_IF_EXISTS;
  using ::remquol _LIBCPP_USING_IF_EXISTS;

  using ::copysign _LIBCPP_USING_IF_EXISTS;
  using ::copysignf _LIBCPP_USING_IF_EXISTS;
  using ::copysignl _LIBCPP_USING_IF_EXISTS;

  using ::nan _LIBCPP_USING_IF_EXISTS;
  using ::nanf _LIBCPP_USING_IF_EXISTS;
  using ::nanl _LIBCPP_USING_IF_EXISTS;

  using ::nextafter _LIBCPP_USING_IF_EXISTS;
  using ::nextafterf _LIBCPP_USING_IF_EXISTS;
  using ::nextafterl _LIBCPP_USING_IF_EXISTS;

  using ::nexttoward _LIBCPP_USING_IF_EXISTS;
  using ::nexttowardf _LIBCPP_USING_IF_EXISTS;
  using ::nexttowardl _LIBCPP_USING_IF_EXISTS;

  using ::fdim _LIBCPP_USING_IF_EXISTS;
  using ::fdimf _LIBCPP_USING_IF_EXISTS;
  using ::fdiml _LIBCPP_USING_IF_EXISTS;

  using ::fmax _LIBCPP_USING_IF_EXISTS;
  using ::fmaxf _LIBCPP_USING_IF_EXISTS;
  using ::fmaxl _LIBCPP_USING_IF_EXISTS;

  using ::fmin _LIBCPP_USING_IF_EXISTS;
  using ::fminf _LIBCPP_USING_IF_EXISTS;
  using ::fminl _LIBCPP_USING_IF_EXISTS;

  using ::fma _LIBCPP_USING_IF_EXISTS;
  using ::fmaf _LIBCPP_USING_IF_EXISTS;
  using ::fmal _LIBCPP_USING_IF_EXISTS;

  using std::lerp _LIBCPP_USING_IF_EXISTS;

  // [c.math.fpclass], classification / comparison functions
  using std::fpclassify _LIBCPP_USING_IF_EXISTS;
  using std::isfinite _LIBCPP_USING_IF_EXISTS;
  using std::isgreater _LIBCPP_USING_IF_EXISTS;
  using std::isgreaterequal _LIBCPP_USING_IF_EXISTS;
  using std::isinf _LIBCPP_USING_IF_EXISTS;
  using std::isless _LIBCPP_USING_IF_EXISTS;
  using std::islessequal _LIBCPP_USING_IF_EXISTS;
  using std::islessgreater _LIBCPP_USING_IF_EXISTS;
  using std::isnan _LIBCPP_USING_IF_EXISTS;
  using std::isnormal _LIBCPP_USING_IF_EXISTS;
  using std::isunordered _LIBCPP_USING_IF_EXISTS;
  using std::signbit _LIBCPP_USING_IF_EXISTS;

  // [sf.cmath], mathematical special functions
#if 0
  // [sf.cmath.assoc.laguerre], associated Laguerre polynomials
  using std::assoc_laguerre;
  using std::assoc_laguerref;
  using std::assoc_laguerrel;

  // [sf.cmath.assoc.legendre], associated Legendre functions
  using std::assoc_legendre;
  using std::assoc_legendref;
  using std::assoc_legendrel;

  // [sf.cmath.beta], beta function
  using std::beta;
  using std::betaf;
  using std::betal;

  // [sf.cmath.comp.ellint.1], complete elliptic integral of the first kind
  using std::comp_ellint_1;
  using std::comp_ellint_1f;
  using std::comp_ellint_1l;

  // [sf.cmath.comp.ellint.2], complete elliptic integral of the second kind
  using std::comp_ellint_2;
  using std::comp_ellint_2f;
  using std::comp_ellint_2l;

  // [sf.cmath.comp.ellint.3], complete elliptic integral of the third kind
  using std::comp_ellint_3;
  using std::comp_ellint_3f;
  using std::comp_ellint_3l;

  // [sf.cmath.cyl.bessel.i], regular modified cylindrical Bessel functions
  using std::cyl_bessel_i;
  using std::cyl_bessel_if;
  using std::cyl_bessel_il;

  // [sf.cmath.cyl.bessel.j], cylindrical Bessel functions of the first kind
  using std::cyl_bessel_j;
  using std::cyl_bessel_jf;
  using std::cyl_bessel_jl;

  // [sf.cmath.cyl.bessel.k], irregular modified cylindrical Bessel functions
  using std::cyl_bessel_k;
  using std::cyl_bessel_kf;
  using std::cyl_bessel_kl;

  // [sf.cmath.cyl.neumann], cylindrical Neumann functions
  // cylindrical Bessel functions of the second kind
  using std::cyl_neumann;
  using std::cyl_neumannf;
  using std::cyl_neumannl;

  // [sf.cmath.ellint.1], incomplete elliptic integral of the first kind
  using std::ellint_1;
  using std::ellint_1f;
  using std::ellint_1l;

  // [sf.cmath.ellint.2], incomplete elliptic integral of the second kind
  using std::ellint_2;
  using std::ellint_2f;
  using std::ellint_2l;

  // [sf.cmath.ellint.3], incomplete elliptic integral of the third kind
  using std::ellint_3;
  using std::ellint_3f;
  using std::ellint_3l;

  // [sf.cmath.expint], exponential integral
  using std::expint;
  using std::expintf;
  using std::expintl;
#endif

  // [sf.cmath.hermite], Hermite polynomials
  using std::hermite;
  using std::hermitef;
  using std::hermitel;

#if 0
  // [sf.cmath.laguerre], Laguerre polynomials
  using std::laguerre;
  using std::laguerref;
  using std::laguerrel;

  // [sf.cmath.legendre], Legendre polynomials
  using std::legendre;
  using std::legendref;
  using std::legendrel;

  // [sf.cmath.riemann.zeta], Riemann zeta function
  using std::riemann_zeta;
  using std::riemann_zetaf;
  using std::riemann_zetal;

  // [sf.cmath.sph.bessel], spherical Bessel functions of the first kind
  using std::sph_bessel;
  using std::sph_besself;
  using std::sph_bessell;

  // [sf.cmath.sph.legendre], spherical associated Legendre functions
  using std::sph_legendre;
  using std::sph_legendref;
  using std::sph_legendrel;

  // [sf.cmath.sph.neumann], spherical Neumann functions;
  // spherical Bessel functions of the second kind
  using std::sph_neumann;
  using std::sph_neumannf;
  using std::sph_neumannl;
#endif
} // namespace std
